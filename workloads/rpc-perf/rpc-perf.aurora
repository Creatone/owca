import os

include('../common.aurora')

#----------------------------------------------------------------------------------------------------
###
# Params which can be modified by exporting environment variables.
###

# Port that stressed application listens on.
application_listen_port = os.environ.get('application_listen_port', 11211)

# Type of application that you want to interact with ("redis" or "twemcache" or "rpc-perf").
application = os.environ.get('application')

# @TODO Variables rpcperf_rate|thread_count|period|amlitude|connections are not used
#   in the code (their values are not injected into config files).
#--
# Number of requests per second to generate (default: 1000; if `rpcperf_amplitude` and `rpcperf_period` are set - maximum of a sine curve).
#rpcperf_rate = os.environ.get('rpcperf_rate', '1000')
#--
# Number of threads used to generate traffic.
# rpcperf_thread_count = os.environ.get('rpcperf_thread_count', '1')
#--
# rpcperf_period and rpcperf_amplitiude are used to generate non-constant number of QpS; see: http://jwilson.coe.uga.edu/EMAT6680/Dunbar/Assignment1/sine_curves_KD.html
# rpcperf_period = os.environ.get('rpcperf_period', '100')
# rpcperf_amplitiude = os.environ.get('rpcperf_amplitiude', '100')
#--
# Number of connections per thread.
#rpcperf_connections = os.environ.get('rpcperf_connections', '1')

# rpc-perf Docker image tag.
rpcperf_image_tag = os.environ.get('rpcperf_image_tag')  # Workaround for "force pull images" defect in Aurora.

# SLO
slo_twemcache = os.environ.get('rpcperf_twemcache_slo')
slo_redis = os.environ.get('rpcperf_redis_slo')

# Additionally used in the code below:
# * 'redis_image_tag'
# * 'twemcache_image_tag'
#----------------------------------------------------------------------------------------------------


# name of a protocol used to generate load ("twemcache" or "redis")
if application == 'twemcache':
    rpcperf_protocol = 'memcache'
    slo = slo_twemcache
if application == 'redis':
    rpcperf_protocol = 'redis'
    slo = slo_redis
sli_metric_name  = "{application}_p99".format(application=application)
load_metric_name = "{application}_rate".format(application=application)

# Add label for identification workload in prometheus.
wrapper_labels["name"] = '%s--%s' % (application, workload_uniq_id)
wrapper_labels["load_generator"] = "rpc-perf"
wrapper_labels["application"] = "{}".format(application)

cpu = 0.5

# JOB definitions
jobs = [
    Service(
        name='redis--%s' % workload_uniq_id,
        cluster=cluster,
        environment='staging' + env_uniq_id,
        role=role,
        enable_hooks=True,
        container=Mesos(
            image=DockerImage(
                name=docker_registry + '/serenity/redis',
                tag=os.environ.get('redis_image_tag'),
            ),
        ),
        constraints=dict(own_ip=application_host_ip),
        task=SequentialTask(
            name='redis--%s' % workload_uniq_id,
            resources=Resources(cpu=cpu, ram=2 * GB, disk=2 * GB),
            processes=[
                Process(
                    name='prep_config',
                    cmdline=
                    "set -x && cp /etc/redis.conf . && sed -i 's/port 6379/port {application_listen_port}/' redis.conf "
                    "&& sed -i 's/bind 127.0.0.1/bind {application_host_ip}/' redis.conf ".format(
                        application_listen_port=application_listen_port,
                        application_host_ip=application_host_ip
                    )
                ),
                Process(
                    name='redis',
                    cmdline='redis-server redis.conf'
                ),
            ],
        ),
    ),
    Service(
        name='twemcache--%s' % workload_uniq_id,
        cluster=cluster,
        environment='staging' + env_uniq_id,
        role=role,
        enable_hooks=True,
        container=Mesos(
            image=DockerImage(
                name=docker_registry + '/serenity/twemcache',
                tag=os.environ.get('twemcache_image_tag'),
            ),
        ),
        constraints=dict(own_ip=application_host_ip),
        task=Task(
            name='twemcache--%s' % workload_uniq_id,
            resources=Resources(cpu=cpu, ram=2 * GB, disk=2 * GB),
            processes=[
                Process(
                    name='twemcache',
                    cmdline=
                        "twemcache --prealloc --hash-power=20 --max-memory=1024 "
                            "--port={application_listen_port} --eviction-strategy=2 --verbosity=4 "
                            "--threads=1 --backlog=128 -u twemcache "
                            "--maximize-core-limit --slab-size=1048576 ".format(
                                    application_listen_port=application_listen_port
                            )
                ),
            ],
        ),
    ),
    Service(
        name='rpc-perf--{}'.format(workload_uniq_id),
        cluster=cluster,
        environment='staging' + env_uniq_id,
        role=role,
        constraints=dict(own_ip=load_generator_host_ip),
        container=Mesos(image=DockerImage(
            name=docker_registry + '/serenity/rpc-perf',
            tag=rpcperf_image_tag,
        )),
        task=Task(
            name='rpc-perf--{}'.format(workload_uniq_id),
            resources=Resources(cpu=cpu, ram=2 * GB, disk=2 * GB),
            processes=[
                Process(
                    name='rpc-perf',
                    cmdline=dedent("""
                        rpc_perf_wrapper.pex
                        --command "rpc-perf --config /etc/rpc-perf.toml -p {protocol} --server {ip}:{port}"
                        --log_level {log_level}
                        --stderr 0
                        --labels "{labels}"
                        --metric_name_prefix "{application}_"
                        --kafka_topic {kafka_topic}
                        --kafka_brokers {kafka_brokers}
                        --peak_load "{peak_load}" --load_metric_name "{load_metric_name}"
                        --slo {slo} --sli_metric_name "{sli_metric_name}"
                            """).format(
                                protocol=rpcperf_protocol, ip=application_host_ip,
                                port=application_listen_port,
                                log_level=wrapper_log_level, labels=wrapper_labels,
                                kafka_topic='owca_apms_'+application,
                                kafka_brokers=wrapper_kafka_brokers,
                                application=application,
                                load_metric_name=load_metric_name,
                                peak_load=str(15000),
                                slo=slo, sli_metric_name=sli_metric_name)
                )
            ],
        )
    ),
]

hooks = [AddMetadata(wrapper_labels)]
