# Copyright (c) 2020 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import logging
import itertools
from typing import Dict, List, Callable, Tuple
import shutil

from wca.scheduler.algorithms import Algorithm
from wca.scheduler.algorithms.bar import BARGeneric
from wca.scheduler.algorithms.fit import FitGeneric
from wca.scheduler.algorithms.nop_algorithm import NOPAlgorithm
from wca.scheduler.cluster_simulator import \
        ClusterSimulator, Node, Resources, Task
from wca.scheduler.data_providers.cluster_simulator_data_provider import (
    ClusterSimulatorDataProvider)
from wca.scheduler.simulator_experiments import experiments_set__generic
from wca.scheduler.simulator_experiments.nodes_generators import prepare_nodes
from wca.scheduler.simulator_experiments.reporting import IterationData, generate_subexperiment_report, generate_experiment_report, \
    wrapper_iteration_finished_callback
from wca.scheduler.simulator_experiments.task_generators import TaskGenerator_classes, \
    TaskGenerator_equal
from wca.scheduler.simulator_experiments.tasksets import task_definitions__artificial
from wca.scheduler.types import ResourceType as rt

log = logging.getLogger(__name__)


nodes_dimensions = {rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}


nodes_definitions = dict(
    aep={rt.CPU: 40, rt.MEM: 1000, rt.MEMBW: 40, rt.MEMBW_READ: 40, rt.MEMBW_WRITE: 10},
    dram={rt.CPU: 40, rt.MEM: 192, rt.MEMBW: 200, rt.MEMBW_READ: 150, rt.MEMBW_WRITE: 150},
)

TASK_SCALE = 4
MACHINE_SCALE = 1

def experiment_1():
    # dimensions supported by simulator
    experiments_set__generic(
        'comparing_bar2d_vs_bar3d__option_A',
        False, # extra chart for every metric generated by algorithm
        (30 * TASK_SCALE,),
        (
            (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial, replicas=10 * TASK_SCALE)),
            # (TaskGenerator_equal, dict(task_definitions=task_definitions, replicas=15)),
            (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=3 * TASK_SCALE, cpu=12 * TASK_SCALE, mem=15 * TASK_SCALE))),
            (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=20 * TASK_SCALE, cpu=5 * TASK_SCALE, mem=5 * TASK_SCALE))),
            (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=30 * TASK_SCALE, cpu=0 * TASK_SCALE, mem=0 * TASK_SCALE))),
            (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=0 * TASK_SCALE, cpu=0 * TASK_SCALE, mem=30 * TASK_SCALE))),
            # (TaskGenerator_equal, dict(task_definitions=task_definitions, replicas=50)),
            # (TaskGenerator_random, dict(task_definitions=task_definitions, max_items=200, seed=300)),
        ),
        (
            prepare_nodes(nodes_definitions,
                dict(aep=0, dram=6*MACHINE_SCALE),
                nodes_dimensions,
            ),
            prepare_nodes(nodes_definitions,
                dict(aep=2*MACHINE_SCALE, dram=6*MACHINE_SCALE),
                nodes_dimensions,
            ),
            prepare_nodes(nodes_definitions,
                dict(aep=0, dram=8*MACHINE_SCALE),
                nodes_dimensions,
            ),
            # prepare_nodes(dict(
            #     apache_pass={rt.CPU: 40, rt.MEM: 1000, rt.MEMBW: 40, rt.MEMBW_READ: 40,
            #                  rt.MEMBW_WRITE: 10, rt.WSS: 256},
            #     dram_only_v1={rt.CPU: 48, rt.MEM: 192, rt.MEMBW: 200, rt.MEMBW_READ: 150,
            #                   rt.MEMBW_WRITE: 150, rt.WSS: 192},
            #     dram_only_v2={rt.CPU: 40, rt.MEM: 394, rt.MEMBW: 200, rt.MEMBW_READ: 200,
            #                   rt.MEMBW_WRITE: 200, rt.WSS: 394}),
            #     dict(apache_pass=5, dram_only_v1=10, dram_only_v2=5),
            #     nodes_dimensions
            # ),
        ),
        (
            # (NOPAlgorithm, {}),
            # (FitGeneric, dict(dimensions={rt.CPU, rt.MEM})),
            # (BARGeneric, dict(dimensions={rt.CPU, rt.MEM}, least_used_weight=0)),
            (BARGeneric, dict(alias='baseline', dimensions={rt.CPU, rt.MEM}, least_used_weight=1)),
            # (FitGeneric, dict(dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE})),
            (BARGeneric, dict(alias='extender', dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=1)),
            # (BARGeneric, dict(dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=0)),
        ),
    )


if __name__ == "__main__":
    try:
        import matplotlib.pyplot as plt
        import numpy as np
    except ImportError:
        # No installed packages required for report generation.
        print('numpy and matplotlib are required!')
        exit(1)

    # init_logging('trace', 'scheduler_extender_simulator_experiments')
    logging.basicConfig(level=logging.INFO)
    # logging.getLogger('wca.scheduler').setLevel(logging.INFO)
    # logging.getLogger('wca.scheduler.cluster_simulator').setLevel(90)
    # logging.getLogger('wca.scheduler.algorithms').setLevel(9)

    experiment_1()
