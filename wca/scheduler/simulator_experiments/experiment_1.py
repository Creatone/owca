# Copyright (c) 2020 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging

from wca.scheduler.algorithms import Algorithm
from wca.scheduler.algorithms.bar import BARGeneric
from wca.scheduler.algorithms.fit import FitGeneric
from wca.scheduler.algorithms.static_assigner import StaticAssigner
from wca.scheduler.algorithms.bar import LeastUsedBAR, BAR, LeastUsed, BARFriend
from wca.scheduler.algorithms.fit import Fit
from wca.scheduler.algorithms.nop_algorithm import NOPAlgorithm

from wca.scheduler.cluster_simulator import \
        ClusterSimulator, Node, Resources, Task
from wca.scheduler.data_providers.cluster_simulator_data_provider import (
    ClusterSimulatorDataProvider)
from wca.scheduler.simulator_experiments import experiments_set__generic
from wca.scheduler.simulator_experiments.nodes_generators import prepare_nodes
from wca.scheduler.simulator_experiments.reporting import IterationData, generate_subexperiment_report, generate_experiment_report, \
    wrapper_iteration_finished_callback
from wca.scheduler.simulator_experiments.task_generators import TaskGenerator_classes, \
    TaskGenerator_equal
from wca.scheduler.simulator_experiments.tasksets import task_definitions__artificial, task_definitions__artificial_2, taskset_dimensions
from wca.scheduler.simulator_experiments.task_generators import TaskGenerator_equal, \
    TaskGenerator_classes, TaskGenerator_random
from wca.scheduler.simulator_experiments.tasksets import task_definitions__artificial, \
    task_definitions__artificial_2dim, nodes_definitions_artificial_2dim
from wca.scheduler.types import ResourceType as rt

log = logging.getLogger(__name__)

dim4 = {rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}
dim2 = {rt.CPU, rt.MEM}
nodes_dimensions = dim4

nodes_definitions = dict(
    aep={rt.CPU: 40, rt.MEM: 1000, rt.MEMBW: 40, rt.MEMBW_READ: 40, rt.MEMBW_WRITE: 10},
    dram={rt.CPU: 80, rt.MEM: 192, rt.MEMBW: 200, rt.MEMBW_READ: 150, rt.MEMBW_WRITE: 150},
)

TASK_SCALE = 50    # of every type (propotionally)
MACHINE_SCALE = 1 # of every type


def experiment_debug():
    experiments_set__generic(
        'debug',
        False,
        (30 * TASK_SCALE,),
        (
            (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial, replicas=10 * TASK_SCALE)),
        ),
        (
            prepare_nodes(nodes_definitions, dict(aep=2 * MACHINE_SCALE, dram=6 * MACHINE_SCALE), nodes_dimensions, ),
        ),
        (
            (LeastUsedBAR, dict(alias='BAR__LU_ON__WEIGHTS_UNUEQUAL', dimensions=dim4, least_used_weight=1, bar_weights={rt.MEM: 0.5})),
            (LeastUsedBAR, dict(alias='BAR__LU_ON__WEIGHTS_EQUAL', dimensions=dim4, least_used_weight=1)),
            (LeastUsedBAR, dict(alias='BAR__LU_ON__WEIGHTS_100x', dimensions=dim4, least_used_weight=100)),
            (LeastUsedBAR, dict(alias='BAR__LU_OFF', dimensions=dim4, least_used_weight=0)),
        ),
    )


def experiment_bar():
    TASK_SCALE = 10
    MACHINE_SCALE = 10

    experiments_set__generic(
        'bar_weights',
        False,
        (30 * TASK_SCALE,),
        (
            (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial_2, counts=dict(mbw=20 * TASK_SCALE, cpu=5 * TASK_SCALE, mem=5 * TASK_SCALE))),
        ),
        (
            prepare_nodes(nodes_definitions,
                dict(aep=2*MACHINE_SCALE, dram=6*MACHINE_SCALE),
                nodes_dimensions,
            ),
        ),
        (
            (BARGeneric, dict(alias='BAR__LU_ON__WEIGHTS_UNUEQUAL', dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=1, bar_weights={rt.MEM:0.5})),
            (BARGeneric, dict(alias='BAR__LU_ON__WEIGHTS_EQUAL', dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=1)),
            (BARGeneric, dict(alias='BAR__LU_ON__WEIGHTS_100x', dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=100)),
            (BARGeneric, dict(alias='BAR__LU_OFF', dimensions={rt.CPU, rt.MEM, rt.MEMBW_READ, rt.MEMBW_WRITE}, least_used_weight=0)),
        ),
    )


def experiment_1():
    experiments_set__generic(
        'intel_demo_local',
        False,  # extra chart for every metric generated by algorithm
        (30 * TASK_SCALE,),
        (
            # (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial, replicas=10 * TASK_SCALE)),
            # (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial, replicas=15)),
            # (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=3 * TASK_SCALE, cpu=12 * TASK_SCALE, mem=15 * TASK_SCALE))),
            # (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=20 * TASK_SCALE, cpu=5 * TASK_SCALE, mem=5 * TASK_SCALE))),
            # (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=30 * TASK_SCALE, cpu=0 * TASK_SCALE, mem=0 * TASK_SCALE))),
            # (TaskGenerator_classes, dict(task_definitions=task_definitions__artificial, counts=dict(mbw=0 * TASK_SCALE, cpu=0 * TASK_SCALE, mem=30 * TASK_SCALE))),
            # (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial, replicas=50)),
            # (TaskGenerator_random, dict(task_definitions=task_definitions__artificial, max_items=200, seed=300)),
            (TaskGenerator_equal, dict(task_definitions=task_definitions__artificial_2dim, replicas=TASK_SCALE)),
        ),
        (
            # prepare_nodes(nodes_definitions, dict(aep=0, dram=6*MACHINE_SCALE), nodes_dimensions, ),
            # prepare_nodes(nodes_definitions, dict(aep=2*MACHINE_SCALE, dram=6*MACHINE_SCALE), nodes_dimensions, ),
            # prepare_nodes(nodes_definitions, dict(aep=0, dram=8*MACHINE_SCALE), nodes_dimensions, ),
            # prepare_nodes(dict(
            #     apache_pass={rt.CPU: 40, rt.MEM: 1000, rt.MEMBW: 40, rt.MEMBW_READ: 40,
            #                  rt.MEMBW_WRITE: 10, rt.WSS: 256},
            #     dram_only_v1={rt.CPU: 48, rt.MEM: 192, rt.MEMBW: 200, rt.MEMBW_READ: 150,
            #                   rt.MEMBW_WRITE: 150, rt.WSS: 192},
            #     dram_only_v2={rt.CPU: 40, rt.MEM: 394, rt.MEMBW: 200, rt.MEMBW_READ: 200,
            #                   rt.MEMBW_WRITE: 200, rt.WSS: 394}),
            #     dict(apache_pass=5, dram_only_v1=10, dram_only_v2=5),
            #     nodes_dimensions
            # ),
            prepare_nodes(nodes_definitions_artificial_2dim, dict(cpuhost=MACHINE_SCALE, memhost=MACHINE_SCALE), nodes_dimensions, ),
        ),
        (
            # Friend, dict(alias='friend', dimensions=dim4),
            # (NOPAlgorithm, {}),
            (Fit, dict(dimensions=dim2)),
            # (Fit, dict(dimensions=dim4)),
            # (LeastUsed, dict(dimensions=dim2)),
            # (LeastUsed, dict(dimensions=dim4)),
            # (BAR, dict(dimensions=dim2)),
            # (BARFriend, dict(dimensions=dim2)),
            # (LeastUsedBAR, dict(alias='kubernetes_baseline', dimensions={rt.CPU, rt.MEM})),
            # (LeastUsedBAR, dict(alias='BAR__LU_OFF', dimensions=dim4, least_used_weight=0)),
            # (LeastUsedBAR, dict(alias='BAR__LU_ON__WEIGHTS_EQUAL', dimensions=dim4, least_used_weight=1)),
            # (LeastUsedBAR, dict(alias='BAR__LU_ON__WEIGHTS_UNUEQUAL', dimensions=dim4, least_used_weight=1, bar_weights={rt.MEM: 0.5})),
        ),
    )


def experiment_static_assigner():
    targeted_assigned_apps_counts = \
        {'aep_0': {'cpu': 1, 'mem': 2, 'mbw': 2},
         'dram_0': {'cpu': 1, 'mem': 0, 'mbw': 0}}

    iterations_data_list = experiments_set__generic(
        'static_assigner',
        False,
        (6,),
        (
            (TaskGenerator_classes,
             dict(task_definitions=taskset_dimensions(nodes_dimensions,
                                                      task_definitions__artificial_2),
                  counts=dict(mbw=2, cpu=2, mem=2))),
        ),
        (
            prepare_nodes(nodes_definitions,
                dict(aep=1, dram=1),
                nodes_dimensions,
            ),
        ),
        (
            (StaticAssigner,
             dict(alias='StaticAssigner',
                  targeted_assigned_apps_counts=targeted_assigned_apps_counts)),
        ),
    )


if __name__ == "__main__":
    try:
        import matplotlib.pyplot as plt
        import numpy as np
    except ImportError:
        # No installed packages required for report generation.
        print('numpy and matplotlib are required!')
        exit(1)

    # init_logging('trace', 'scheduler_extender_simulator_experiments')
    logging.basicConfig(level=logging.INFO)
    logging.getLogger('wca.scheduler').setLevel(logging.INFO)
    logging.getLogger('wca.scheduler.cluster_simulator').setLevel(9)
    logging.getLogger('wca.scheduler.algorithms').setLevel(logging.DEBUG)
    # logging.getLogger('wca.scheduler.algorithms.bar').setLevel(9)

    # experiment_debug()
    # experiment_1()
    # experiment_bar()
    experiment_static_assigner()
